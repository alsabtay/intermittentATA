<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Intermittent demand time series analysis using the Ata Method based on the ATAforecasting package. — intermittentATA • intermittentATA</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Intermittent demand time series analysis using the Ata Method based on the ATAforecasting package. — intermittentATA"><meta property="og:description" content="Intermittent Ata Method is based on Croston's (1972) &amp;lt;doi:10.2307/3007885&amp;gt; method for intermittent demand forecasting, also described in Shenstone and Hyndman (2005) &amp;lt;doi:10.1002/for.963&amp;gt;.
Croston's method involves using simple exponential smoothing (SES) on the non-zero elements of the time series and a separate application of (SES) to the times between non-zero elements of the time series."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">intermittentATA</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/alsabtay/intermittentATA/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Intermittent demand time series analysis using the Ata Method based on the ATAforecasting package.</h1>
    <small class="dont-index">Source: <a href="https://github.com/alsabtay/intermittentATA/blob/HEAD/R/intermittent_ata.r" class="external-link"><code>R/intermittent_ata.r</code></a></small>
    <div class="hidden name"><code>intermittentATA.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Intermittent Ata Method is based on Croston's (1972) &lt;doi:10.2307/3007885&gt; method for intermittent demand forecasting, also described in Shenstone and Hyndman (2005) &lt;doi:10.1002/for.963&gt;.
Croston's method involves using simple exponential smoothing (SES) on the non-zero elements of the time series and a separate application of (SES) to the times between non-zero elements of the time series.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu"><a href="https://alsabtay.github.io/intermittentATA/reference/intermittentATA-package.html" class="external-link">intermittentATA</a></span><span class="op">(</span><span class="va">formula</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>formula</dt>
<dd><p>Model specification (see "Specials" section).</p></dd>


<dt>...</dt>
<dd><p>Other arguments</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    

<p>A model specification.</p>
    </div>
    <div id="details">
    <h2>Details</h2>
    <p>There are two variant methods available which apply multiplicative correction factors
to the forecasts that result from the original Croston's method. For the
Syntetos-Boylan approximation (`type = "sba"`), this factor is \(1 - \alpha / 2\),
and for the Shale-Boylan-Johnston method (`type = "sbj"`), this factor is
\(1 - \alpha / (2 - \alpha)\), where \(\alpha\) is the smoothing parameter for
the interval SES application.</p>
<p>Returns IntermittentATA[intermittent.type, D(p,q,phi)(E,T,S), I(p,q,phi)(E,T,S)] applied to time series data.</p>
<p>The Ata method based on the modified simple exponential smoothing as described in Yapar, G. (2016) &lt;doi:10.15672/HJMS.201614320580&gt; ,
Yapar G., Capar, S., Selamlar, H. T., Yavuz, I. (2017) &lt;doi:10.15672/HJMS.2017.493&gt; and Yapar G., Selamlar, H. T., Capar, S., Yavuz, I. (2019)
&lt;doi:10.15672/hujms.461032&gt; is a new univariate time series forecasting method which provides innovative solutions to issues faced during
the initialization and optimization stages of existing methods.
Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting.
It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
This methodology performed well on the M3 and M4-competition data.</p>
    </div>
    <div id="specials">
    <h2>Specials</h2>
    


<p>The _specials_ define the methods and parameters for the components (level, trend, accuracy, transform, holdout) of an ATA method for both of demand and interval time series.</p>
<p>There are a couple of limitations to note about ATA method:</p>
<p>- It supports only additive error term.
- It does not support exogenous regressors.
- It does not support missing values. You can complete missing values in the data with imputed values (e.g. with [tsibble::fill_gaps()], [tidyr::fill()], or by fitting a different model type and then calling [fabletools::interpolate()]) before fitting the model.</p>
<div class="section">
<h3 id="d-level">d_level<a class="anchor" aria-label="anchor" href="#d-level"></a></h3>
<p>The `level` special is used to specify the form of the level term for the demand time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">d_level</span><span class="op">(</span>parP <span class="op">=</span> <span class="cn">NULL</span>, level_fixed <span class="op">=</span> <span class="cn">TRUE</span>, initial_level <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`parP`</td><td>The value of the smoothing parameter for the level. If `p = 0`, the level will not change over time. Conversely, if `p = 1` the level will update similarly to a random walk process. If NULL or "opt", it is estimated. <code>p</code> has all integer values from 1 to <code>length(data)</code>.</td></tr><tr><td>`level_fixed`</td><td>If TRUE, "pStarQ"  --&gt; First, fits ATA(p,0) where p = p* is optimized for q=0. Then, fits ATA(p*,q) where q is optimized for p = p*.</td></tr><tr><td>`initial_level`</td><td>If NULL, "none" is default. If "none", ATA Method calculates the pth observation in <code>data</code> for level. If "mean", ATA Method calculates average of first p value in <code>data</code>for level. If "median", ATA Method calculates median of first p value in <code>data</code>for level.</td></tr></table></div>

<div class="section">
<h3 id="d-trend">d_trend<a class="anchor" aria-label="anchor" href="#d-trend"></a></h3>
<p>The `trend` special is used to specify the form of the trend term and associated parameters for the demand time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">d_trend</span><span class="op">(</span>type <span class="op">=</span> <span class="st">"A"</span>, parQ <span class="op">=</span> <span class="cn">NULL</span>, initial_trend <span class="op">=</span> <span class="st">"none"</span>, opt_trend <span class="op">=</span> <span class="st">"none"</span>,</span>
<span>       parPHI <span class="op">=</span> <span class="cn">NULL</span>, parPHI_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.8</span>, <span class="fl">1.0</span><span class="op">)</span>, parPHI_increment <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span>       uroot_test <span class="op">=</span> <span class="st">"adf"</span>, uroot_alpha <span class="op">=</span> <span class="fl">0.05</span>, uroot_type <span class="op">=</span> <span class="st">"level"</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`type`</td><td>The form of the trend term: either none ("N"), additive ("A"), multiplicative ("M") or damped variants ("Ad", "Md").</td></tr><tr><td>`parQ`</td><td>The value of the smoothing parameter for the slope. If `q = 0`, the slope will not change over time. Conversely, if `q = 1` the slope will have mean of past slopes.</td></tr><tr><td>`parPHI`</td><td>The value of the dampening parameter for the slope. If `phi = 0`, the slope will be dampened immediately (no slope). Conversely, if `phi = 1` the slope will not be dampened.</td></tr><tr><td>`parPHI_range`</td><td>If `phi=NULL`, `phi_range` provides bounds for the optimised value of `phi`.</td></tr><tr><td>`parPHI_increment`</td><td>If `phi=NULL`, `parPHI_increment` provides increment step for searching `phi`. If NULL, `parPHI_increment` will be determined as the value that allows the `parPHI_range` to be divided into 20 equal parts.</td></tr><tr><td>`initial_trend`</td><td>If NULL, "none" is default. If "none", ATA Method calculates the qth observation in <code>data</code> for trend. If "mean", ATA Method calculates average of first q value in <code>X(T)-X(T-1)</code> for trend. If "median", ATA Method calculates median of first q value in <code>X(T)-X(T-1)</code> for trend.</td></tr><tr><td>`trend_opt`</td><td>Default is `none`. If `fixed` is set, "pBullet" --&gt; Fits ATA(p,1) where p = p* is optimized for q = 1. If `search` is set "qBullet" --&gt; Fits ATA(p,q) where p = p* is optimized for q = q* (q &gt; 0). Then, fits ATA(p*,q) where q is optimized for p = p*.</td></tr><tr><td>`uroot_test`</td><td>Type of unit root test before all type seasonality test. Possible values are "adf", "pp" and "kpss".</td></tr><tr><td>`uroot_alpha`</td><td>Significant level of the unit root test, possible values range from 0.01 to 0.1.</td></tr><tr><td>`uroot_type`</td><td>Specification of the deterministic component in the regression for unit root test. Possible values are "level" and "trend".</td></tr><tr><td>`uroot_maxd`</td><td>Maximum number of non-seasonal differences allowed.</td></tr></table></div>

<div class="section">
<h3 id="d-accuracy">d_accuracy<a class="anchor" aria-label="anchor" href="#d-accuracy"></a></h3>
<p>The `accuracy` special is used to the optimization criterion for selecting the best ATA Method forecasting for the demand time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">d_accuracy</span><span class="op">(</span>criteria <span class="op">=</span> <span class="st">"sMAPE"</span>, nmse <span class="op">=</span> <span class="fl">3</span>, ic <span class="op">=</span> <span class="st">"AIC"</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`criteria`</td><td>Accuracy measure for optimization of the best ATA Method forecasting. IF NULL, `sMAPE` is default.</td></tr><tr><td>`nmse`</td><td>If `accuracy.type == "AMSE"`, `nmse` provides the number of steps for average multistep MSE `(2&lt;=nmse&lt;=30)`.</td></tr><tr><td>`ic`</td><td>The information criterion used in selecting the model.</td></tr></table></div>

<div class="section">
<h3 id="d-transform">d_transform<a class="anchor" aria-label="anchor" href="#d-transform"></a></h3>
<p>The `transform` special is used to provide the applicability of different types of transformation techniques for the demand data to which the ATA method will be applied.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">d_transform</span><span class="op">(</span>method<span class="op">=</span><span class="st">"none"</span>, order <span class="op">=</span> <span class="st">"none"</span>, lambda <span class="op">=</span> <span class="cn">NULL</span>, shift <span class="op">=</span> <span class="fl">0</span>,</span>
<span>          bcMethod <span class="op">=</span> <span class="st">"guerrero"</span>, bcLower <span class="op">=</span> <span class="fl">0</span>, bcUpper <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`method`</td><td>Transformation method  --&gt; "Box_Cox", "Sqrt", "Reciprocal", "Log", "NegLog", "Modulus", "BickelDoksum", "Manly", "Dual", "YeoJohnson", "GPower", "GLog". If the transformation process needs shift parameter, it will be calculated required shift parameter automatically.</td></tr><tr><td>`order`</td><td>Default is "none. If "before", Box-Cox transformation family will be applied and then seasonal decomposition techniques will be applied. If "after", seasonal decomposition techniques will be applied and then Box-Cox transformation family will be applied.</td></tr><tr><td>`lambda`</td><td>Box-Cox power transformation family parameter. If NULL, data transformed before model is estimated.</td></tr><tr><td>`shift`</td><td>Box-Cox power transformation family shifting parameter. If NULL, data transformed before model is estimated.</td></tr><tr><td>`bcMethod`</td><td>Choose method to be used in calculating lambda. "guerrero" is default. Other method is "loglik".</td></tr><tr><td>`bcLower`</td><td>Lower limit for possible lambda values. The lower value is limited by -5. Default value is 0.</td></tr><tr><td>`bcUpper`</td><td>Upper limit for possible lambda values. The upper value is limited by 5. Default value is 5.</td></tr></table></div>

<div class="section">
<h3 id="d-holdout">d_holdout<a class="anchor" aria-label="anchor" href="#d-holdout"></a></h3>
<p>The `holdout` special is used to improve the optimized parameter value obtained for the ATA Method forecasting for the demand time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">d_holdout</span><span class="op">(</span>holdout <span class="op">=</span> <span class="cn">FALSE</span>, adjustment <span class="op">=</span> <span class="cn">TRUE</span>, set_size <span class="op">=</span> <span class="cn">NULL</span>, onestep <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`holdout`</td><td>Default is FALSE. If TRUE, ATA Method uses the holdout forecasting for accuracy measure to select the best parameter set. In holdout forecasting, this parameter divides `data` into two parts: training set (in-sample) and validation set (holdout set).</td></tr><tr><td>`adjustment`</td><td>Default is TRUE. If TRUE, `parP` will be adjusted by length of training, validation sets and main data set when the holdout forecasting is active.</td></tr><tr><td>`set_size`</td><td>If `holdout` is TRUE, this parameter divides `data` into two parts: training set (in-sample) and validation set (holdout set). Also, this parameter will be same as `h` for defining holdout set.</td></tr><tr><td>`onestep`</td><td>Default is FALSE. if TRUE, the dynamic forecast strategy uses a one-step model multiple times `h` (forecast horizon) where the holdout prediction for the prior time step is used as an input for making a prediction on the following time step.</td></tr></table></div>

<div class="section">
<h3 id="i-level">i_level<a class="anchor" aria-label="anchor" href="#i-level"></a></h3>
<p>The `level` special is used to specify the form of the level term for the interval time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">i_level</span><span class="op">(</span>parP <span class="op">=</span> <span class="cn">NULL</span>, level_fixed <span class="op">=</span> <span class="cn">TRUE</span>, initial_level <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`parP`</td><td>The value of the smoothing parameter for the level. If `p = 0`, the level will not change over time. Conversely, if `p = 1` the level will update similarly to a random walk process. If NULL or "opt", it is estimated. <code>p</code> has all integer values from 1 to <code>length(data)</code>.</td></tr><tr><td>`level_fixed`</td><td>If TRUE, "pStarQ"  --&gt; First, fits ATA(p,0) where p = p* is optimized for q=0. Then, fits ATA(p*,q) where q is optimized for p = p*.</td></tr><tr><td>`initial_level`</td><td>If NULL, "none" is default. If "none", ATA Method calculates the pth observation in <code>data</code> for level. If "mean", ATA Method calculates average of first p value in <code>data</code>for level. If "median", ATA Method calculates median of first p value in <code>data</code>for level.</td></tr></table></div>

<div class="section">
<h3 id="i-trend">i_trend<a class="anchor" aria-label="anchor" href="#i-trend"></a></h3>
<p>The `trend` special is used to specify the form of the trend term and associated parameters for the interval time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">i_trend</span><span class="op">(</span>type <span class="op">=</span> <span class="st">"A"</span>, parQ <span class="op">=</span> <span class="cn">NULL</span>, initial_trend <span class="op">=</span> <span class="st">"none"</span>, opt_trend <span class="op">=</span> <span class="st">"none"</span>,</span>
<span>       parPHI <span class="op">=</span> <span class="cn">NULL</span>, parPHI_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.8</span>, <span class="fl">1.0</span><span class="op">)</span>, parPHI_increment <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span>       uroot_test <span class="op">=</span> <span class="st">"adf"</span>, uroot_alpha <span class="op">=</span> <span class="fl">0.05</span>, uroot_type <span class="op">=</span> <span class="st">"level"</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`type`</td><td>The form of the trend term: either none ("N"), additive ("A"), multiplicative ("M") or damped variants ("Ad", "Md").</td></tr><tr><td>`parQ`</td><td>The value of the smoothing parameter for the slope. If `q = 0`, the slope will not change over time. Conversely, if `q = 1` the slope will have mean of past slopes.</td></tr><tr><td>`parPHI`</td><td>The value of the dampening parameter for the slope. If `phi = 0`, the slope will be dampened immediately (no slope). Conversely, if `phi = 1` the slope will not be dampened.</td></tr><tr><td>`parPHI_range`</td><td>If `phi=NULL`, `phi_range` provides bounds for the optimised value of `phi`.</td></tr><tr><td>`parPHI_increment`</td><td>If `phi=NULL`, `parPHI_increment` provides increment step for searching `phi`. If NULL, `parPHI_increment` will be determined as the value that allows the `parPHI_range` to be divided into 20 equal parts.</td></tr><tr><td>`initial_trend`</td><td>If NULL, "none" is default. If "none", ATA Method calculates the qth observation in <code>data</code> for trend. If "mean", ATA Method calculates average of first q value in <code>X(T)-X(T-1)</code> for trend. If "median", ATA Method calculates median of first q value in <code>X(T)-X(T-1)</code> for trend.</td></tr><tr><td>`trend_opt`</td><td>Default is `none`. If `fixed` is set, "pBullet" --&gt; Fits ATA(p,1) where p = p* is optimized for q = 1. If `search` is set "qBullet" --&gt; Fits ATA(p,q) where p = p* is optimized for q = q* (q &gt; 0). Then, fits ATA(p*,q) where q is optimized for p = p*.</td></tr><tr><td>`uroot_test`</td><td>Type of unit root test before all type seasonality test. Possible values are "adf", "pp" and "kpss".</td></tr><tr><td>`uroot_alpha`</td><td>Significant level of the unit root test, possible values range from 0.01 to 0.1.</td></tr><tr><td>`uroot_type`</td><td>Specification of the deterministic component in the regression for unit root test. Possible values are "level" and "trend".</td></tr><tr><td>`uroot_maxd`</td><td>Maximum number of non-seasonal differences allowed.</td></tr></table></div>

<div class="section">
<h3 id="i-accuracy">i_accuracy<a class="anchor" aria-label="anchor" href="#i-accuracy"></a></h3>
<p>The `accuracy` special is used to the optimization criterion for selecting the best ATA Method forecasting for the interval time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">i_accuracy</span><span class="op">(</span>criteria <span class="op">=</span> <span class="st">"sMAPE"</span>, nmse <span class="op">=</span> <span class="fl">3</span>, ic <span class="op">=</span> <span class="st">"AIC"</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`criteria`</td><td>Accuracy measure for optimization of the best ATA Method forecasting. IF NULL, `sMAPE` is default.</td></tr><tr><td>`nmse`</td><td>If `accuracy.type == "AMSE"`, `nmse` provides the number of steps for average multistep MSE `(2&lt;=nmse&lt;=30)`.</td></tr><tr><td>`ic`</td><td>The information criterion used in selecting the model.</td></tr></table></div>

<div class="section">
<h3 id="i-transform">i_transform<a class="anchor" aria-label="anchor" href="#i-transform"></a></h3>
<p>The `transform` special is used to provide the applicability of different types of transformation techniques for the interval data to which the ATA method will be applied.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">i_transform</span><span class="op">(</span>method<span class="op">=</span><span class="st">"none"</span>, order <span class="op">=</span> <span class="st">"none"</span>, lambda <span class="op">=</span> <span class="cn">NULL</span>, shift <span class="op">=</span> <span class="fl">0</span>,</span>
<span>          bcMethod <span class="op">=</span> <span class="st">"guerrero"</span>, bcLower <span class="op">=</span> <span class="fl">0</span>, bcUpper <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`method`</td><td>Transformation method  --&gt; "Box_Cox", "Sqrt", "Reciprocal", "Log", "NegLog", "Modulus", "BickelDoksum", "Manly", "Dual", "YeoJohnson", "GPower", "GLog". If the transformation process needs shift parameter, it will be calculated required shift parameter automatically.</td></tr><tr><td>`order`</td><td>Default is "none. If "before", Box-Cox transformation family will be applied and then seasonal decomposition techniques will be applied. If "after", seasonal decomposition techniques will be applied and then Box-Cox transformation family will be applied.</td></tr><tr><td>`lambda`</td><td>Box-Cox power transformation family parameter. If NULL, data transformed before model is estimated.</td></tr><tr><td>`shift`</td><td>Box-Cox power transformation family shifting parameter. If NULL, data transformed before model is estimated.</td></tr><tr><td>`bcMethod`</td><td>Choose method to be used in calculating lambda. "guerrero" is default. Other method is "loglik".</td></tr><tr><td>`bcLower`</td><td>Lower limit for possible lambda values. The lower value is limited by -5. Default value is 0.</td></tr><tr><td>`bcUpper`</td><td>Upper limit for possible lambda values. The upper value is limited by 5. Default value is 5.</td></tr></table></div>

<div class="section">
<h3 id="i-holdout">i_holdout<a class="anchor" aria-label="anchor" href="#i-holdout"></a></h3>
<p>The `holdout` special is used to improve the optimized parameter value obtained for the ATA Method forecasting for the interval time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">i_holdout</span><span class="op">(</span>holdout <span class="op">=</span> <span class="cn">FALSE</span>, adjustment <span class="op">=</span> <span class="cn">TRUE</span>, set_size <span class="op">=</span> <span class="cn">NULL</span>, onestep <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`holdout`</td><td>Default is FALSE. If TRUE, ATA Method uses the holdout forecasting for accuracy measure to select the best parameter set. In holdout forecasting, this parameter divides `data` into two parts: training set (in-sample) and validation set (holdout set).</td></tr><tr><td>`adjustment`</td><td>Default is TRUE. If TRUE, `parP` will be adjusted by length of training, validation sets and main data set when the holdout forecasting is active.</td></tr><tr><td>`set_size`</td><td>If `holdout` is TRUE, this parameter divides `data` into two parts: training set (in-sample) and validation set (holdout set). Also, this parameter will be same as `h` for defining holdout set.</td></tr><tr><td>`onestep`</td><td>Default is FALSE. if TRUE, the dynamic forecast strategy uses a one-step model multiple times `h` (forecast horizon) where the holdout prediction for the prior time step is used as an input for making a prediction on the following time step.</td></tr></table></div>

<div class="section">
<h3 id="intermittent">intermittent<a class="anchor" aria-label="anchor" href="#intermittent"></a></h3>
<p>The `intermittent` special is used to improve the optimized parameter value obtained for the ATA Method forecasting for the interval time series.</p><div class="sourceCode"><pre><code><span></span>
<span><span class="fu">intermittent</span><span class="op">(</span>type <span class="op">=</span> <span class="st">"croston"</span><span class="op">)</span></span></code></pre></div>

<table class="table table"><tr><td>`type`</td><td>Default is "croston". For the Syntetos-Boylan approximation (`type = "sba"`), this factor is \(1 - \alpha / 2\), and for the Shale-Boylan-Johnston method (`type = "sbj"`), this factor is \(1 - \alpha / (2 - \alpha)\), where \(\alpha\) is the smoothing parameter for the interval ATA Method application.</td></tr></table></div>

    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://alsabtay.github.io/intermittentATA/" class="external-link">intermittentATA</a></span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://tsibble.tidyverts.org/reference/as-tsibble.html" class="external-link">as_tsibble</a></span><span class="op">(</span><span class="va">fmcgData</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> <span class="fu"><a href="https://fabletools.tidyverts.org/reference/model.html" class="external-link">model</a></span><span class="op">(</span>crostonata <span class="op">=</span> <span class="fu"><a href="https://alsabtay.github.io/intermittentATA/reference/intermittentATA-package.html" class="external-link">intermittentATA</a></span><span class="op">(</span><span class="va">value</span> <span class="op">~</span> <span class="fu">d_trend</span><span class="op">(</span>type <span class="op">=</span> <span class="st">"M"</span>, parQ <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">i_trend</span><span class="op">(</span><span class="st">"A"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">intermittent</span><span class="op">(</span><span class="st">"croston"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="color: #949494;"># A mable: 1 x 1</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                                          crostonata</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                                                             <span style="color: #949494; font-style: italic;">&lt;model&gt;</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> <span style="color: #BCBCBC;">1</span> &lt;IntermittentATA[croston, D(2,1,0) (A,M,N), I(3,3,0.2) (A,Ad,N)]&gt;</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Ali Sabri Taylan, Hanife Taylan Selamlar, Guckan Yapar.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

